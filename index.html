<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>AI Events 2025 - ALL EVENTS</title>
    <style>
        body { background: white; color: black; font-family: Arial; margin: 20px; }
        .debug { background: yellow; padding: 10px; margin: 10px 0; border: 2px solid red; font-weight: bold; }
        #eventsContainer { background: white; color: black; padding: 20px; border: 2px solid blue; }
        .event { border: 1px solid black; margin: 10px 0; padding: 15px; background: #f5f5f5; }
        .event-title { font-size: 18px; font-weight: bold; color: #000; margin-bottom: 8px; }
        .event-info { color: #333; margin: 3px 0; font-size: 14px; }
        .stats { background: #e6f7ff; padding: 10px; margin: 10px 0; border: 1px solid #0066cc; }
        .error { background: #ffeeee; color: #cc0000; padding: 10px; margin: 10px 0; border: 1px solid #cc0000; }
        .loading { background: #fff3cd; color: #856404; padding: 10px; margin: 10px 0; border: 1px solid #ffc107; }
    </style>
</head>
<body>
    <h1>AI Events 2025 - ALL EVENTS LOADED</h1>
    <div class="debug" id="debug">Starting to load events...</div>
    <div class="stats" id="stats">Stats will appear here...</div>
    <div class="loading" id="progress">Progress: 0/59 files loaded...</div>
    <div id="eventsContainer"><h2>Events will appear here...</h2></div>
    
    <script>
        console.log('=== BULLETPROOF EVENT LOADER STARTING ===');
        
        // All 59 JSON files in events directory
        const eventFiles = [
            'adapta_summit_2025.json',
            'agtech_meeting_2025.json',
            'ai_summit_bix_2025.json',
            'ai_summit_brasil_sp_2025.json',
            'ai_workshop_march.json',
            'bate_papo_ia_futuro_trabalho_2025.json',
            'big_data_brazil_experience_2025.json',
            'biotech_agro_health_2025.json',
            'bootcamp_ia_negocios_2025.json',
            'cbta_2025.json',
            'cidia_2025.json',
            'conecta_industria_2025.json',
            'conexao_mulher_ia_2025.json',
            'conferences.json',
            'curso_aplicacao_ia_trabalho_2025.json',
            'curso_ia_generativa_encantado_2025.json',
            'curso_ia_generativa_ensino_2025.json',
            'curso_ia_teoria_pratica_2025.json',
            'data_science_summit_2025.json',
            'deep_learning_course.json',
            'encontro_ia_politica_2025.json',
            'eramia_rs_2025.json',
            'event_template.json',
            'expoinovacao_2025.json',
            'futurecom_2025.json',
            'genai_summit.json',
            'hackathon_innova_saude_2025.json',
            'health_meeting_brasil_2025.json',
            'ia_conference_brasil_2025.json',
            'ia_summit_blumenau_2025.json',
            'ia_summit_upf_2025.json',
            'icbdai_porto_alegre_2025.json',
            'icbdai_sao_paulo_2025.json',
            'icml_2025.json',
            'imersao_ia_pratica_negocios_2025.json',
            'innovation_week_sjc_2025.json',
            'inovar_sc_2025.json',
            'live_sbagro_ia_2025.json',
            'mercopar_2025.json',
            'neurips_2025.json',
            'r_day_2025.json',
            'rio_preto_tech_summit_2025.json',
            'rpa_ai_congress_curitiba_2025.json',
            'sao_paulo_tech_week_2025.json',
            'semana_caldeira_2025.json',
            'semana_de_dados_2025.json',
            'seminario_automacao_isa_2025.json',
            'seminario_pesquisa_ia_generativa_2025.json',
            'simposio_simplas_2025.json',
            'smart_energy_2025.json',
            'south_stat_meeting_2025.json',
            'startup_investment_summit_2025.json',
            'startup_summit_2025.json',
            'super_bots_experience_2025.json',
            'tdc_sao_paulo_2025.json',
            'techstars_weekend_ai_curitiba_2025.json',
            'urban_tech_forum_2025.json',
            'workshop_fig_ladm_3d_2025.json',
            'workshop_rh_okrs_ia_2025.json'
        ];
        
        // Global variables for tracking
        let totalFilesLoaded = 0;
        let totalEventsFound = 0;
        let futureEvents = [];
        let pastEvents = 0;
        let errors = [];
        const cutoffDate = '2025-08-08';
        
        function updateProgress() {
            const progressElement = document.getElementById('progress');
            const debugElement = document.getElementById('debug');
            const statsElement = document.getElementById('stats');
            
            try {
                progressElement.innerHTML = `Progress: ${totalFilesLoaded}/${eventFiles.length} files loaded, ${errors.length} errors`;
                
                debugElement.innerHTML = `LOADING: ${totalFilesLoaded}/${eventFiles.length} files processed. Events found: ${totalEventsFound}`;
                
                statsElement.innerHTML = 
                    `<strong>CURRENT STATS:</strong><br>` +
                    `Files loaded: ${totalFilesLoaded}/${eventFiles.length}<br>` +
                    `Total events found: ${totalEventsFound}<br>` +
                    `Events before Aug 8: ${pastEvents}<br>` +
                    `Future events: ${futureEvents.length}<br>` +
                    `Errors: ${errors.length}`;
                    
                console.log(`Progress: ${totalFilesLoaded}/${eventFiles.length}, Events: ${totalEventsFound}, Future: ${futureEvents.length}, Errors: ${errors.length}`);
            } catch (e) {
                console.error('Error updating progress:', e);
            }
        }
        
        function displayEvents() {
            const container = document.getElementById('eventsContainer');
            
            try {
                // Sort by date
                futureEvents.sort((a, b) => {
                    if (!a.startDate) return 1;
                    if (!b.startDate) return -1;
                    return a.startDate.localeCompare(b.startDate);
                });
                
                let html = `<h2>AI Events 2025 - Future Events (${futureEvents.length} events)</h2>`;
                
                if (futureEvents.length === 0) {
                    html += '<p>No future events found or events failed to load.</p>';
                    if (errors.length > 0) {
                        html += '<h3>Errors encountered:</h3>';
                        errors.forEach(error => {
                            html += `<p style="color: red;">â€¢ ${error}</p>`;
                        });
                    }
                } else {
                    futureEvents.forEach((event, index) => {
                        const formattedDate = formatDate(event.startDate, event.endDate);
                        const typeInfo = event.type ? ` (${event.type})` : '';
                        
                        html += `
                            <div class="event">
                                <div class="event-title">${index + 1}. ${event.name}${typeInfo}</div>
                                <div class="event-info"><strong>Date:</strong> ${formattedDate}</div>
                                <div class="event-info"><strong>Location:</strong> ${event.city || 'TBA'}, ${event.country || 'TBA'}</div>
                                ${event.venue ? `<div class="event-info"><strong>Venue:</strong> ${event.venue}</div>` : ''}
                                ${event.format ? `<div class="event-info"><strong>Format:</strong> ${event.format}</div>` : ''}
                            </div>
                        `;
                    });
                }
                
                container.innerHTML = html;
                console.log('Events displayed successfully');
            } catch (error) {
                console.error('Error displaying events:', error);
                container.innerHTML = `<h2>ERROR DISPLAYING EVENTS</h2><p>${error.message}</p>`;
            }
        }
        
        async function loadSingleFile(filename) {
            try {
                console.log(`Loading: ${filename}`);
                const response = await fetch(`events/${filename}`);
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status} for ${filename}`);
                }
                
                const data = await response.json();
                return { filename, data, success: true };
            } catch (error) {
                const errorMsg = `Failed to load ${filename}: ${error.message}`;
                console.warn(errorMsg);
                errors.push(errorMsg);
                return { filename, error: error.message, success: false };
            }
        }
        
        function normalizeEvent(eventData, filename) {
            try {
                if (!eventData) return null;
                
                // Extract name (try multiple field names)
                const name = eventData.name || 
                            eventData.event_name || 
                            eventData.full_name || 
                            eventData.title ||
                            filename.replace('.json', '').replace(/_/g, ' ');
                
                // Extract dates (try multiple structures)
                let startDate = null;
                let endDate = null;
                
                if (eventData.dates) {
                    startDate = eventData.dates.start;
                    endDate = eventData.dates.end;
                } else if (eventData.date) {
                    startDate = eventData.date.start;
                    endDate = eventData.date.end;
                } else if (eventData.start_date) {
                    startDate = eventData.start_date;
                    endDate = eventData.end_date;
                }
                
                // Skip if no start date
                if (!startDate) {
                    console.warn(`No start date found for ${filename}`);
                    return null;
                }
                
                // Extract location
                const location = eventData.location || {};
                const city = location.city || eventData.city || '';
                const country = location.country || eventData.country || '';
                const venue = location.venue || eventData.venue || '';
                
                // Extract type/format
                const type = eventData.type || 
                            eventData.event_type || 
                            'event';
                
                const format = eventData.format || (location.online_platform ? 'online' : '');
                
                return {
                    name,
                    startDate,
                    endDate,
                    city,
                    country,
                    venue,
                    type,
                    format,
                    source: filename
                };
            } catch (error) {
                console.error(`Error normalizing event from ${filename}:`, error);
                return null;
            }
        }
        
        function processEventData(result) {
            try {
                if (!result.success) return;
                
                const { filename, data } = result;
                
                // Skip template files
                if (filename === 'event_template.json') {
                    console.log('Skipping template file');
                    return;
                }
                
                // Handle conferences.json (array format)
                if (filename === 'conferences.json' && data.ai_conferences_2025) {
                    console.log(`Processing ${data.ai_conferences_2025.length} conferences from conferences.json`);
                    data.ai_conferences_2025.forEach(event => {
                        totalEventsFound++;
                        const eventData = normalizeEvent(event, 'conference');
                        if (eventData && eventData.startDate >= cutoffDate) {
                            futureEvents.push(eventData);
                        } else if (eventData) {
                            pastEvents++;
                        }
                    });
                    return;
                }
                
                // Handle individual event files
                totalEventsFound++;
                const eventData = normalizeEvent(data, filename);
                if (eventData && eventData.startDate >= cutoffDate) {
                    futureEvents.push(eventData);
                    console.log(`Added future event: ${eventData.name}`);
                } else if (eventData) {
                    pastEvents++;
                    console.log(`Skipped past event: ${eventData.name}`);
                } else {
                    console.warn(`Failed to normalize event from ${filename}`);
                }
            } catch (error) {
                const errorMsg = `Error processing ${result.filename}: ${error.message}`;
                console.error(errorMsg);
                errors.push(errorMsg);
            }
        }
        
        function formatDate(start, end) {
            try {
                if (!start) return 'TBA';
                
                const startFormatted = new Date(start).toLocaleDateString('en-US', {
                    year: 'numeric',
                    month: 'short',
                    day: 'numeric'
                });
                
                if (end && end !== start) {
                    const endFormatted = new Date(end).toLocaleDateString('en-US', {
                        year: 'numeric',
                        month: 'short',
                        day: 'numeric'
                    });
                    return `${startFormatted} - ${endFormatted}`;
                }
                
                return startFormatted;
            } catch (error) {
                console.error('Error formatting date:', error);
                return 'Invalid Date';
            }
        }
        
        async function loadAllEvents() {
            const debugElement = document.getElementById('debug');
            
            try {
                console.log('=== STARTING BULLETPROOF LOADER ===');
                debugElement.innerHTML = 'STARTING: Initializing bulletproof loader...';
                updateProgress();
                
                // Process files in smaller batches to avoid overwhelming the browser
                const batchSize = 10;
                const batches = [];
                
                for (let i = 0; i < eventFiles.length; i += batchSize) {
                    batches.push(eventFiles.slice(i, i + batchSize));
                }
                
                console.log(`Processing ${batches.length} batches of ${batchSize} files each`);
                
                for (let batchIndex = 0; batchIndex < batches.length; batchIndex++) {
                    const batch = batches[batchIndex];
                    console.log(`Processing batch ${batchIndex + 1}/${batches.length}`);
                    
                    // Load batch in parallel
                    const batchPromises = batch.map(filename => loadSingleFile(filename));
                    const batchResults = await Promise.all(batchPromises);
                    
                    // Process results
                    batchResults.forEach(result => {
                        if (result.success) {
                            totalFilesLoaded++;
                            processEventData(result);
                        }
                        updateProgress();
                    });
                    
                    // Small delay between batches to keep UI responsive
                    await new Promise(resolve => setTimeout(resolve, 100));
                }
                
                console.log('=== ALL FILES PROCESSED ===');
                console.log(`Total files loaded: ${totalFilesLoaded}/${eventFiles.length}`);
                console.log(`Total events found: ${totalEventsFound}`);
                console.log(`Future events: ${futureEvents.length}`);
                console.log(`Past events: ${pastEvents}`);
                console.log(`Errors: ${errors.length}`);
                
                debugElement.innerHTML = `SUCCESS: Loaded ${totalFilesLoaded}/${eventFiles.length} files. Found ${futureEvents.length} future events.`;
                
                if (errors.length > 0) {
                    debugElement.innerHTML += ` (${errors.length} errors - see console)`;
                }
                
                displayEvents();
                
            } catch (error) {
                console.error('CRITICAL ERROR in loadAllEvents:', error);
                debugElement.innerHTML = `CRITICAL ERROR: ${error.message}`;
                
                // Try to display whatever we have
                try {
                    displayEvents();
                } catch (displayError) {
                    console.error('Failed to display events after error:', displayError);
                }
            }
        }
        
        // Auto-start when page loads
        document.addEventListener('DOMContentLoaded', function() {
            console.log('DOM loaded, starting event loader...');
            loadAllEvents();
        });
        
        // Backup trigger in case DOMContentLoaded already fired
        if (document.readyState === 'loading') {
            console.log('Document still loading, waiting for DOMContentLoaded');
        } else {
            console.log('Document already loaded, starting immediately');
            setTimeout(loadAllEvents, 100);
        }
        
        // Manual trigger for debugging
        window.loadEvents = loadAllEvents;
        window.displayEvents = displayEvents;
        
        console.log('=== BULLETPROOF LOADER INITIALIZED ===');
    </script>
</body>
</html>
EOF < /dev/null